## 使类和成员的可访问性最小化
   规则一：尽可能的使每个类或者成员不被外界访问。
尽量包私有的类，这样就是包独立的而不是对包外开放的API
如果只有一个类用到了该类那么应该变成那个类的内部类
除了常量以外，其他成员变量不应该是public的
## 在共有类中使用访问方法而非公有域
    就是使用getter和setter

## 使可变性最小化
    不可变类，在构建的时候提供所有内容，，比如Sting, Integer
    原则：不提供任何改变状态的方法、final类不会被继承、所有成员变量都是final的私有的、不对外暴露引用，或者使用外来引用
    缺点：两个差别不大的类需要构建两个出来。如果用这个类执行多步操作，最后只需要结果，中间产生的变量可以舍弃，这样就会很浪费性能，这个时候最好的做法是提供一个配套类，比如StringBuilder和String之间的关系。

## 复合优先于继承
    继承会打破封装性，最好是专门设计的类，并且有完善的文档。
    因为不知道父类的很多行为，只在子类中覆盖一部分使用的时候很脆弱。并且如果覆盖进行了修改子类也需要修改
   使用复合就不会有这些问题。比如装饰器模式
   只有完全的is-a关系才用集成

## 要么为继承而设计，并提供文档说明，要么就禁止集成
    文档要说明被覆盖的方法的自用性。好的API文档应该只描述方法做了什么而不描述怎么去做的。因此这样的文档破坏了封装性。
    一定不要在父类的构造器中引用会被覆盖的方法，因为父类构造器先与子类构造，就引用子类中的方法可能会有问题。
    
## 接口优于抽象类
    接口可以多继承，可以不依赖层次框架
    通过为每一个接口提供骨架实现类 AbstractInterface就能为程序提供实现上的帮助

## 接口只用于定义类型
    有一种错误的使用方式就是接口常量类，他暴露了代码细节到API中，应该分布到每个类中去，并且尽量使用枚举

## 类层次优于标签类
    首先是标签类：
public class Figure {
	private int type;		// 0为矩形，1为圆形
	
	public int area(){
		if(type == 0){
			
		}else{
			
		}
		return 0;
	}
}
这样的接口，有个表示实例类型的标签type，应该修改为area()提出为一个接口，而两种类型分别为集成或者实现了该接口或者抽象类的类

## 用函数对象表示策略
    函数对象就是只含有一个方法提供一些功能但是没有状态的对象。比如Comparetor类的实现者。这个最佳实践的意思就是使用策略模式，把策略接口传给宿主类进行使用    
    另外只会被一个类使用的策略可以作为内部类
## 优先考虑静态成员类
    非静态成员类会持有外部类的实例，这样会增加构造时间和内存
    非静态成员类常用来做Adapter模式，比如List的iterator, Map的keySet视图,它提供了把一个类当成另外一个类处理的能力
    静态成员类的常用用法是代表外围类的组件，比如Map中的Entry来关联Key和value.
    匿名内部类，通常用来动态的创建函数对象，比如spring中的一些模板，或者是创建过程对象，比如Runnable.
    局部类，方法内部的类，和匿名在同一个地方，但是不需要实现接口的时候可以用它

