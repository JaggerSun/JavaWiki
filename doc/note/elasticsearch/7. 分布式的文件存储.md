深入到细节。
#如何知道文档输入哪一个分片，或者存入到哪个分片。
hash(routing) % number_of_primary_shards
hash取余，这也是为什么主分片的数量不能改
routing可以id或者是啥
# 分片交互

![](http://git.oschina.net/wzj777/princeWiki/raw/master/pic/elasticsearch/es-1.png)

两个索引P0P1，每个有一主两从分片， 因为同一个分片不在同一个节点上，所以是如上的样子。
这个信息保存在所有节点上，所以只要发信息给任一个节点，都能够转发请求，类似于forword。
发送请求的时候可以轮询着发送，这样就能够负载均衡了。

# 新建，索引和删除
    1. 客户端发送给node1请求
    2. node1通过_id找到其所属的主分片0，比如在node3上，然后转发请求到node3.
    3. 在node3上执行，如果执行成功，成功的话就转发请求到其他从分片也就是node1和node2上去，当所有节点都成功，这个时候node3把结果报告给node1. node1返回结果给客户端。
 一些设置：
    replication 默认是sync,如果是async.则在主分片执行后就会返回信息给客户端，可以提高吞吐，但是丢失了一致性。还有可能导致es过载
    consistency 默认是quorum标示是复制了过半的数量就返回。 
    默认的策略：int( (primary + number_of_replicas) / 2 ) + 1
还可以是one和all. 需要注意，如果number_of_replicas设置为3，那么至少要有3个以上的节点才有用。否则
        timeout: 连接分片的超时时间。

#检索
    1. 发送请I去给node1
    2. 根据_id找到其对应的分片，因为检索是读请求，所以任何的分片都可以，不一定要是主节点。所以三个节点选一个，比如是node2
    3. 然后node2执行检索返回给客户端。
# 局部和批量
    差不多跟上面的， 但是是多个命令搞完之后才去做同步。  局部的时候有尝试3次的规定，如果尝试3次不行就不行了。
    批量的强格式要求是为了没有冗余的结构。