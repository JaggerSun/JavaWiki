分布式领域CAP理论，
Consistency(一致性), 数据一致更新，所有数据变动都是同步的
Availability(可用性), 好的响应性能
Partition tolerance(分区容错性) 可靠性

定理：任何分布式系统只可同时满足二点，没法三者兼顾。
所以就有个取舍了。
5.1 更新一致性
        来，看个场景，有个界面是按看见的人+1， 当前是2，两个人看见，都改成3，提交，如果没有并发判断，那么最终的结果就是错的。   
        通常解决有两种方式： 乐观和悲观。
        乐观：信任每次都是好的，然后处理冲突。 CAS, 需要先测试当前的值和上一次读入是否是同一个值。A，B一起提交，A的操作先被执行，B提交(3, 2)但是数据库是3，会提示B冲突了，B就需要先看下最新的，然后再提交
        悲观：不让冲突发生。 就是写入锁，系统确保某个时间内只有一个人有写入锁，A，B一起提交。A有锁，B提交会提示B没有操作权限，然后B看新的数据，再觉得提交，这种方式并不能保证是递增的。 这种方式适用于执行数据库的自增，比如update a set i = i + 1; 如果是并发的时候因为有写入锁，会给操作排序，就能自增了。
        悲观锁会带来性能下降。
        单节点的写操作还是可以使用上面的锁，但是如果是多节点的话，如果是使用双写这样的情况就又会有冲突， A写A节点，B写b节点，都会提交就会产生冲突了
        所以现实中一般都是使用单节点写的方式
5.2 读取一致性
        逻辑一致性问题， 就是A先往购物车放了一个商品， A修改了商品悉尼型，然后B读取了商品和单价得到了总价， 然后A改了商品的单价。 这个时候B拿到的就是脏数据了。  R数据库提供了事务解决这个问题。
        聚合数据库在一个聚合内部是原子的。
        更新不同聚合的时候有可能有短暂的不一致。
        复制一致性问题， 多个复制节点存在一定的时间差，所以可能会有问题。
        上面说的这些问题，最后还是会一致的，这个叫做最终一致性。
        具有最终一致性的系统可以让用户看起来好看一点的技术：回话一致性。 既读出自己所写内容的一致性。
                这种可以使用黏性回话既绑定节点的回话来实现，但是会影响负载均衡器。
                还有一种是版本戳，具体的下一节讲。

5.3 放宽一致性约束
        但服务器的一致性就是事务，可以通过隔离级别来放松。一般用read-commited就够了。
        很多系统已经放弃了事务，因为影响太大。
        
    有关CAP。
         一致性。 不解释了，就是所有节点的更新和读取都是一致的。
        可用性。        没有单点故障
                                不管什么情况下，节点都能返回结果，或者成功或者失败，而不是无法连接这样的提示。
                                如果可以同某个节点通信，那么该节点能够同时处理读写操作。
        分区耐受性。 网络故障导致分成了两个独立的集群，集群仍然可用。 脑裂了。
        单服务器满足一致性， 可用性也可以看作满足，不涉及分区
        放宽一致性的例子， 如果是双节点，如果其中一个节点挂掉了，为了保证强一致性，实际上我们应该全停止。
            让我们允许不全停止，一个主一个备，这个时候网络分区了， 这个时候导致备机只读了，这样影响了可用性。如果为了提升可用性，那么我们就让备机也可度，就造成了一定时间的不一致。
            实际上我们更多的是通过异步的方式来更新缓存，保证最终一致性，以次来提升并发，负载能力。
              大部分时间考虑的是一致性和延迟之间的取舍问题。  
5.4 放宽“持久性”约束
        更新内存，定期更新磁盘。问题在于一旦发生故障，则会导致丢失。比如回话状态就可以这样。
        主从复制，主突然挂了也会有这个问题。可以强制让主去确认从已经写好了。这样可以减少问题。

5.5 仲裁
    这个设计Proxy。  强一致性要求所有节点回复。 Proxy,要求N/2 + 1个节点回复。

        