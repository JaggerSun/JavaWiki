线程安全
       首先无状态的对象肯定是线程安全的。
       
       原子性
                竞争条件   多个线程并发访问和修改同一个变量，最终结果由线程的顺序决定时，称之为竞争条件， 竞争的失败者将会决定对象的状态。  比如一个线程对一个变量+1 另外一个线程对变量+2， 在基于 读-改-写模式的情况下， 两个线程并发访问的时候，变量的最终值会由竞争失败者决定。
                除了读-改-写模式，还有check-then-act 检查再运行的模式，检查到执行这段时间内，有可能检查的结果已经过期，这也是一种竞争条件。
                比如单例模式中的懒汉模式 if(instance == null) { instance == new }这种情况，是有可能创建两个实例的。
                为了解决如上这种读-改-写及检查再运行模式引起的线程安全问题，办法是使这两个符合操作变为原子操作(A,B两个操作，从A的角度看B要么全执行完要么没执行，有点像事物)。紧紧对于像由于自增自检这样的符合操作可以使用AtomicLong这样本身附带原子自增操作的类，当然更复杂的就只能使用锁了。
        刚才说了自增的读写改模式可以用AtomicLong来解决，类似于if(AtomicLong.zizeng){AtomicLong.doSomething}这种分为两步的操作及时对象本身的单个方法是原子操作也会有问题，  只要是复合操作都会有安全的问题，就需要使用锁来解决。  syn..关键字，  这个关键字会得到一个内部所，其他线程访问时会阻塞，同一个线程访问时可以重进入， 重进入是JVM会记录锁的占有者和计数器，当前线程进入会。

        
什么原因造成了线程安全问题
       首先需要把问题约束在同一个JVM进程中。因为现在包含了很多共享内存映射，分布式缓存，缓存服务器等相关的技术，会给跨进程的线程安全或者是说数据同步带来问题。
       按照Java的内存模型，线程将会私有PC计数器，虚拟机栈。 公用JVM堆内存。
       1. 当有线程并发的时候，因为多个线程可能操作同一块堆内存地址这样就会造成资源竞争引发线程安全问题。
       2. JVM server模式下对程序进行的优化：主要是重排序和执行时为了性能会把主存中的数据拷贝一份到线程自己的寄存器中，操作该对象并回写主内存。 这两种方式都会导致当前线程操作的数据对于其他线程来讲可见性方面出现问题，因此我统一称为可见性问题。
       3. JVM可能将long，double等64位数的操作转化为两个32位的操作。


可见性问题
      1. 内存拷贝
                
      2. 重新排序



锁
     可重入的， 递归死锁
     会降低活跃度运行能，比如servlet的service会使得其编程单线程的，大大影响并发。  所以通常耗时长的操作不能加锁。
     计数器使用了AotomicLong.
     
        
        