[转]TCP如何保证它的通信的可靠性
2014-9-3阅读45 评论0

主要用下列方式提供可靠性

1,应用数据被分割成TCP认为最适合发送的数据块,这和UDP完全不同,应用程序产生的数据报长度将保持不变,由TCP传递给IP的信息单元称为报文段,或段

2,当TCP发出一个段后,它启动一个定时器,等待目的端确认收到这个报文段.如果不能及时收到一个确认,将重发这个报文段,

3,当TCP收到发自TCP连接另一端的数据,它将发送一个确认,这个确认不是立即发送,通常将推迟几分之一秒.

4,TCP将保持它首部和数据的检验和,.这是一个端到端的检验和,目的是检测数据在传输过程中的任何变化,如果收到段的检验和有差错,TCP将丢弃这个报文段和不确认收到此报文段(希望发端超时并重发)

5,TCP报文段作为IP数据报来传输,而IP数据报的到达可能会失序,因此TCP报文段的到达也可能会失序,如果必要,TCP将对收到的数据进行重新排序,将收到的数据以正确的顺序交给应用层,

6,IP数据报可能会出现重复,TCP的接收端必须丢弃重复的数据.

7,TCP还能提供流量控制,TCP连接的每一方都有固定大小的缓冲空间.TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据,这将防止较快主机致使较慢主机的缓冲区溢出,

两个应用程序通过TCP连接交换8bit字节构成的字节流,TCP不在字节流中插入记录标识符.我们将这称之为字节流服务(byte stream service).如果一方的应用程序先传10字节,又传20字节,再传50字节,连接的另一方将无法了解发方每次发送了多少字节,收方可以分4次接收这80字节,每次收20字节,一端将字节流放到TCP连接上,同样的字节流也将出现在TCP连接的另一端上

TCP对字节流的内容不做任何解释,TCP不知道传输的数据字节流是二进制数据,还是ASCII字符,EBCDIC字符或者其他类型数据.对字节流的解释由TCP连接双方的应用层解释.

这种对字节流处理方式与Unix操作系统对文件的处理方式很相似,Unix的内核对一个应用读或写的内容不做任何解释,而是交给应用程序处理,对Unix的内核来说,它无法区分一个二进制文件与一个文本文件.



三次握手

第一次

第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
第二次

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
完成三次握手，客户端与服务器开始传送数据，

来源： <http://baike.baidu.com/link?url=IbY6SmDrnvoC3D4ZsNYteejsm6-f5-jDSdVtbOjeqAJ3TK8V-z2pie8o38TEIi1rfwuFkOTUmxRe0FP3fQVjvK>
 




TIME_WAIT

TIME_WAIT状态存在的理由
----------------------------
TCP/IP协议就是这样设计的，是不可避免的。主要有两个原因:
1）可靠地实现TCP全双工连接的终止
TCP协议在关闭连接的四次握手过程中，最终的ACK是由主动关闭连接的一端（后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将响应RST分节，B端收到后将此分节解释成一个错误（在java中会抛出connection reset的SocketException)。
因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持TIME_WAIT状态 。
 
2）允许老的重复分节在网络中消逝 
TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个迟到的迷途分节到达时可能会引起问题。在关闭“前一个连接”之后，马上又重新建立起一个相同的IP和端口之间的“新连接”，“前一个连接”的迷途重复分组在“前一个连接”终止后到达，而被“新连接”收到了。为了避免这个情况，TCP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。
 
 
 
 
MSL时间
----------------------------
MSL就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间IP数据包将在网络中消失 。MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒。
 
TIME_WAIT状态维持时间
----------------------------
TIME_WAIT状态维持时间是两个MSL时间长度，也就是在1-4分钟。Windows操作系统就是4分钟。
 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。
（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。
（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。
（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）
TCP采用四次挥手关闭连接如图所示为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？
这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

来源： <http://baike.baidu.com/link?url=RO3Lk9loq9oEtnIrevouRZ5tuBB8wGeuuko63mepFTlTM8n6B6xvfdEf6AAJSA-u1fVe-3RqN2gn-SAlwyefgq>
 