内存模型， 分为了主存和线程工作内存。 
volatile语义：关闭重排序，保证可见性(也就是回写主存)。

##Java与线程
1. 映射到系统线程上
2. 线程状态更细分了一下，无限等待是没到Timeout的Object.wait()和.join()
        限期等待是带了的 和Thread.sleep().
##线程安全的实现方法
1. 互斥同步
通过锁来实现，可重入锁，再一次进入+1， 获取对象锁失败则等待。

ReentrantLock 增加了一些功能：
    公平锁，等待时间绝对谁先进入锁
    绑定多个条件
    等待可中断。 比如tryLock(time)
2. 非阻塞同步
    互斥同步的主要问题是线程上下文切换带来的问题上
    互斥是一种悲观的锁，只要不同步就肯定会出问题。
    CAS是一种乐观的锁， 认为大多数情况下都是成功的，不成功的时候使用重试机制再来

3. 无同步方案
    ThreadLocal  在同一线程共享的数据放到这个里面。  比如经典的web模型，都是一个请求一个线程导致很多对象都能在一个请求中使用。

##锁优化
###自旋锁与自适应自旋
    锁定状态持续时间很短，但是线程置换开销很大，这种可以让后面的线程自旋等待，默认等待10次，可以改
    自适应是1.6的新特性，会判断如果这个自旋成功过，则会让他多旋几次，如果失败了很多次，则少旋几次。

###所消除
    便一起减去除锁，比如在方法内的stringbuffer.append就会涉及这一点。

###锁粗化
    也是append这种，如果多次对一个对象反复加锁解锁，则会执行锁粗化

###轻量级锁
    既先使用CAS进行检查，如果成功就不用使用互斥量了。  这种是基于CAS成功率很高的情况下
###偏向锁
    
