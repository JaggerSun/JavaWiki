主要是想一些场景，会给以后需要继续学的东西

## 来了新硬件，调大-Xmx和-Xms之后 网站不定期出现长时间没有响应的情况。
    检查发现是因为设置内存太大一次FullGC的时间太长了，并且有代码从磁盘读取文件，造成了文件序列化产生了很大的对象，直接进入老年代了。
    对于高性能硬件的利用，通常有两种办法：
        1. 通过64位使用大内存
                对于对停顿时间敏感的系统， 分配超大堆的前提是有把握吧Full GC的频率控制的足够低，比如每天晚上一次FullGC.
                保证这种，要求不能产生批量的，长时间存在的大对象，保证老年代的稳定。
                如果非要用要考虑停顿， 64位的性能，dump日志太大
        2. 使用若干个小虚拟机建立集群
                通常就是单机多个应用，加一个反向转发比如nginx来利用这个资源。
                不考虑状态保留，热转移之类的高可用需求使用无Session复制的亲和式集群比较好。
                可能会有如下的问题：
    尽量避免节点竞争全局资源，比如磁盘。
    很难最高效率的利用某些资源池，譬如连接池，尽管可以使用JNDI但是会引入额外的复杂性
    缓存浪费

## 集群同步导致内存溢出
        使用JGroup做组播的时候如果消息失败会进行重发，如果当前网络不好的时候会堆积很多重发数据引起内存溢出
## 对外内存导致内存溢出
通常如下的地方会引起内存溢出：
Direct Memory: NIO会用到， 可通过-XX:MaxDirectMemorySize设置
线程堆栈：
Socket缓存区：
JNI代码：

## 调用外部命令导致系统变慢
    Runtime.getRuntime().exec()很耗资源，会克隆一个和当前虚拟机拥有同样变量的环境，然后执行外外部命令。

实战：
## 改善一个系统运行性能。
1. 升级jdk版本，但是要进行性能测试
2. 调整内存设置控制垃圾收集频率
    Minor GC太频繁，一般是设置的太小了，使用-Xmn调整新生代大小。
    然后看老生代的，如果发现都是内存不够用了，且伴随着扩展，则可以设置为固定值不让看扩展。
    还可以使用jstat -gccause查询一下最近一次gc的原因。 比如是不是System.gc()触发的呀，减少触发次数
    在注意CPU使用的情况，如果利用率很低，使用CMS收集器提高CPU利用率，减少等待时间。-XX:+UseConcMarkSweepGC -XX:+UseParNewGC但是可能会增多full gc，可以用-XX:CMS...设这个比率

