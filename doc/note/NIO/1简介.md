CPU不是束缚， IO成为瓶颈

JVM的 I/O模型与操作系统不匹配(操作系统成块处理数据，I/O用流，字节来处理)，因为JVM的封装很多的高效的I/O并不支持。
因此出现了NIO

NIO提供了新的抽象Channel和Selector,这套新类提供了强大的框架涵盖了普遍操作系统提供的高效I/O,并且还提供了新的服务提供接口SPI，允许接入新型通道和选择器

首先看一下操作系统层面，如何做I/O的
1. 虚拟内存分页
比较早些的时候内存很小，比如只有254K, 但是一个进程需要使用的内存为20M，那么实际内存就不够用了，为此操作系统提供了虚拟内存，对于有些操作系统只会给用户空间分配虚拟内存。    那么怎样把虚拟内存对应到物理内存呢，就是内存分页技术了。
为此虚拟内存和物理内存被分成了单位大小相同的页帧， 然后为了知道虚拟内存怎样映射到物理内存为每个进程设计了页表(可以认为是根据虚拟地址查找物理地址的表)。 CPU和物理内存之间有一个组件叫MMU， 用来查找页表，把虚拟内存地址，转化为物理内存地址。如果当前不存在一个物理地址对应了入参的虚拟地址，那么会向CPU提交一个页错误，然后CPU会把控制权交给内核执行页面调度，把数据放到物理内存，同时刷新页表及MMU，MMU会返回正确的物理内存地址给用户进程， 用户进程基本感觉不到这个过程。

基于虚拟内存，来看一下实际操作系统层面的I/O的情形： 注意下面所说的内存都是指的虚拟内存。
2.  缓存区

用户进程 发起I/O操作， 先在内存用户空间开一片缓存区，然后发送操作系统命令把自己缓冲区填满或者清空，  内核随即找到数据，对内存缓冲区进行高速缓存或者预读取，  然后把内存缓冲区中的数据拷贝进用户空间指定的缓冲区去

不直接拷贝的原因是因为磁盘上的整块，但是缓冲区中可能是不连续的，在内核缓冲区中可以进行分解整合的操作
一些增加效率的办法：
1.2 发散/汇聚
许多操作系统能把分解/组合的操作进行的很高效， 只需要一个系统调用，就能够传递一连串的缓冲区地址给操作系统，操纵系统顺序的填满或者清空，  然后再同步到多个用户空间的缓冲区中。 这样就能够减少系统调用次数。
1.3 虚拟内存
    1. 多个虚拟内存地址可以映射到同一块内存，  可以解决设备控制器不能直接存储到用户空间的问题。
    2. 寻址空间大于物理内存：就是通过分页来解决的了

3. 具体的文件I/O
文件是一个逻辑的概念，  组织了一组不连续的磁盘上的数据，所有的文件I/O都是基于页面调度完成的。操作系统执行文件I/O的全过程：
文件系统也有页的概念，通常是内存页的整数倍
从文件系统知道数据具体放在哪些文件系统页上
在内核空间分配足够的内存能够容纳文件系统页，然后对内存也与文件系统页之间建立映射
为每一个内存产生页错误，虚拟内存系统俘获页错误，安排页面调入，从硬盘读取页内容，使页有效
一旦有效后，文件系统对原始数据进行解析，取得所需文件内容和文件名可读状态等属性
内存映射文件
    传统文件I/O通过用户进程发布多个read()和write()系统调用来传输数据的，因为文件系统页与用户缓冲区之间肯定不是一一对应的关系，所以会发生多次拷贝，从文件系统页到内核缓冲区，再到用户缓冲区。   为此操作系统支持了内存映射I/O， 文件系统页与用户空间缓冲区是一一对应的，都对应到一段内存中。 这样的好处是：
    用户进程操作文件数据与操作内存时一样的，因此不需要read()和write()系统调用，这两个调用都会涉及从内核缓冲区到用户缓冲区，和文件系统页之间的数据拷贝
用户进程触碰到映射内存空间是，会自动产生页错误，从而将文件数据从磁盘读进内存，修改了会自动标记为脏，随后刷新到磁盘。
数据总是按页对齐的，无需执行缓冲拷贝
还可以实现进程共享内存
文件锁定
        一般用来控制共享信息的更新方式或者用于事物隔离。
        文件锁定可以细致到单个字节，这样对于协调多个进程访问文件的不同区域
       两种方式：共享锁(多个共享锁可以加在同一个区域)， 独占锁(区域被锁后，不允许其他锁定再起作用)
        进程A读文件请求共享锁， B读文件请求共享锁，二者可以同时读文件，这个时候写文件过来要请求独占锁，会阻塞知道这个内存区域的所有共享锁和独占锁都接触才可以写，如果正在写，那么读和写都是不可以再加在上面的。


流I/O 
    磁盘是块I/O， 但是对于很多设备，比如键盘，打印机网络等I/O字节流必须顺序读取，这就是流I/O。
    一般比块设备慢，经常是间歇性输入。   有两个模式，非块模式： 进程查看流上是否有输入，没有可以看别的，有就处理输入。
    另一种是就绪型设备， 跟非块类似，把查看流是否就绪的任务交给了操作系统，操作系统查看多个流是否就绪。
