任务分割。  
大任务分割成小的任务，然后发给N多worker去处理
每个worker接收 key-value ,然后输出key-value.
最后对所有输出进行聚合。

使用MapReduce框架就能够只关心worker干什么， 而最最复杂的
怎么分割任务，
怎么调度任务，
怎么处理错误，
集群中的通信这些棘手的问题都不需要开发人员关心。 
能够让没有并行计算和分布式开发经验的程序员充分利用分布式带来的性能提升。

就好像Java的ThreadPool等等，减少了并发变成的复杂度。

我们日常会有很多概念上容易理解，但是输入量巨大的业务。
比如处理大量原始数据：文档抓取，web请求日志
类型衍生数据：倒排索引、web文档的土结构的各种标示，网络爬虫抓取页面数量汇总、每天被请求的最多的查询集合等等。
为了解决这个问题，抽象一个模型出来，输入通过Map来得到一个中间的key-value集合，然后通过reduce操作所有相同key的reduce操作。  用这个模型屏蔽并行计算、容错、数据分布、负载均衡等复杂的细节。

## 编程模型
map(String key, String value):
    // key: document name// value: document contentsfor each word w in value:
        EmitIntermediate(w, “1″);
reduce(String key, Iterator values):
    // key: a word// values: a list of counts
    int result = 0;
    for each v in values:
        result += ParseInt(v);
    Emit(AsString(result));
Map 接收一个输入的key-value，然后输出一个key-value的list.
        比如上面的这个
                {"file_url", "file_content"}  ->  {"word1":1}
                                                          {"word1":1}
                                                          {"word2":1}
        然后reduce的时候就会收到：
                {"word1":["1", "1", "1"]}  然后最后的输出就是{"word1":3}了。
        这个表达更准确一点：
                map(k1,v1) ->list(k2,v2)
             reduce(k2,list(v2)) ->list(v2)
还有一些常用的方法的map-reduce的模型表示：
分布式的Grep：Map函数输出匹配某个模式的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。
计算URL访问频率：Map函数处理日志中web页面请求的记录，然后输出(URL,1)。Reduce函数把相同URL的value值都累加起来，产生(URL,记录总数)结果。
每个主机的检索词向量：检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些词。Map函数为每一个输入文档输出(主机名,检索词向量)，其中主机名来自文档的URL。Reduce函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的(主机名,检索词向量)。
倒排索引：Map函数分析每个文档输出一个(词,文档号)的列表，Reduce函数的输入是一个给定词的所有（词，文档号），排序所有的文档号，输出(词,list（文档号）)。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。
分布式排序：Map函数从每个记录提取key，输出(key,record)。Reduce函数不改变任何的值。这个运算依赖分区机制(在4.1描述)和排序属性(在4.2描述)。

## 实现
使用不同的环境有不同的实现。 google的环境：
x86架构、运行Linux操作系统、双处理器、2-4GB内存的机器。
普通的网络硬件设备，每个机器的带宽为百兆或者千兆，但是远小于网络的平均带宽的一半。 （alex注：这里需要网络专家解释一下了）
集群中包含成百上千的机器，因此，机器故障是常态。
存储为廉价的内置IDE硬盘。一个内部分布式文件系统用来管理存储在这些磁盘上的数据。文件系统通过数据复制来在不可靠的硬件上保证数据的可靠性和有效性。
用户提交工作（job）给调度系统。每个工作（job）都包含一系列的任务（task），调度系统将这些任务调度到集群中多台可用的机器上。


