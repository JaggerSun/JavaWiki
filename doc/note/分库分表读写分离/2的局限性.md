###前端NIO，后端阻塞
后端跟Mysql的交互式阻塞模式的，NIO只给出了框架，还没来得及实现。

### Cobar的高可用
一个节点配置了两个dataSource, 然后心跳检测， 因为上面说到的问题，所以可能不停来回切换，还有可能导致双写，影响数据一致性。

### Cobar集群下的双写。
两个Cobar节点，每个节点都配置了两个数据源， 然后Cobar A挂了，
切换到CobarB,没啥问题，挺好的，然后数据源1挂了，B把数据源切换到2
数据源1好了，变成了备机。
然后重启CobarA,好吧，因为默认第一个为写，所以当前的状态为：
A用1写，
B用2写，所以就双写了。

这种只要做了集群，只要发生了节点切换的时候重启一下节点就有可能发生， 解决的办法是每次重启所有的节点。

### 部分NIO
结构：
SQL->FrontConnection->Cobar->MySQLChanel->MySQL
FrontConnection实现了NIO。
MySQLChannel是BIO的，原因是因为，比较难，不好做。
导致了两个线程池， 线程浪费。
吞吐量有问题，还有可能假死。

### 写队列阻塞
分两步，
1: 后端接收数据库查询结果发给FrontConnetion进入一个处理队列
2: 前端进行一些处理返回给客户端
因为一般后端比前端要快很多，所以队列中就会变满。

就会阻塞，并且没有通知机制。
Mycat使用链表，不会阻塞，更好的并发性。
有配置阈值，能够发送告警。

### SQL批处理
JDBC的批处理
ps.addBatch()
ps.executeBatch()
Cobar把每一条语句都用数据库单独的线程来执行，提高了执行速度。
但是有个问题是事务性哈， 因为跨了连接，就需要额外处理事务， 比如在接受到错误的时候批量回滚。
但是可能会因为宕机引起别的问题。

### 增加死锁
因为SQL语句会被分成多个， 类似于一个线程需要并发锁定多个资源， 这个多个资源的锁定顺序没有保证，所以更容易出现死锁。

### 分表导致了连接池变小。
因为分片表在多个库中，一个数据库实例通常在1000-3000的连接， 如果分成50个分表库，这样每个库就剩下20多连接了，链接池不能共享，这样降低了并发性能。

### 热装载会断连接。
支持配置文件热装载，但是会断连接。

### 不支持读写分离

### 不可控的主从切换








