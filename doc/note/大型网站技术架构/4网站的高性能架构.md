##性能测试
###角度
 - 用户视角的网站性能
用户点击到看到屏幕响应的感受。
受到网络带宽， 浏览器解析HTML速度。以及服务器处理的影响
可以通过优化HTML，利用多域名提高并发，调整浏览器缓存策略，使用CDN，反省代理
 - 开发人员视角
主要关注响应延迟，系统吞吐量，并发处理能力等技术指标。  
常用优化手段：使用缓存，使用集群提高吞吐能力， 使用异步消息加快响应和削峰，程序优化
 - 运维视角
 更关注资源利用，硬件信息。可以用更好的服务器，虚拟化技术等

###测试指标
 - 响应时间。           用测试程序记录这个时间，可以使用重复多次求平均的方式来算出响应时间很快的接口
响应时间从大到小：  打开网站(秒)/查询一条索引记录(10ms)/机械磁盘一次寻址/机械磁盘顺序读1M/远程分布式缓存度一条数据0.5ms/SSD顺序读1M0.3ms/本地内存读取1M(10微妙)/Java本地方法调用(几微妙)/网络传输2KB(1微妙)
 -  并发数       同时处理的请求数
 - 吞吐量        用request/m来横朗，或者TPS每秒事务数等
想下告诉， 并发是在跑的车， 吞吐量是过收费站的车，响应时间是车速。  堵车就是瓶颈了。
 -  性能计数器
   System Load top命令。 对象与线程数，内存使用，CPU使用，磁盘与网络I/O等指标
###测试方法
 - 性能测试        测试预先设定的性能指标是否能达到
 - 负载测试        到临界值，查看负载能力
 - 压力测试        持续加压，到崩溃为止，看能承受多大
 - 稳定性测试    加压比较长的时间来查看是否稳定，成波浪形，

![](http://git.oschina.net/wzj777/princeWiki/raw/master/pic/struts/s-5.png)
![](http://git.oschina.net/wzj777/princeWiki/raw/master/pic/struts/s-6.png)

### 报告

![](http://git.oschina.net/wzj777/princeWiki/raw/master/pic/struts/s-7.png)

###性能优化策略
检查请求处理各个环节的日志， 分析哪儿环节慢了。检查监控数据，分析影响性能的主要因素， 软件，网络，硬件，架构
优化分为WEB前端，应用服务器， 数据存储。

##WEB前端优化
 - 减少http请求， 无状态协议，三次握手，每个请求服务器都要独立的线程处理。手段是合并CSS，合并JavaScript,合并图片。
 - 使用浏览器缓存， 使用HTTP头总的cache-control和expires属性设置缓存。当需要刷新这个缓存的时候可以改变文件的名称。
缓存文件更新时不要一次全部更新，以免带来骤增。
 - 启用压缩。  启用gzip压缩。会给cpu带来一定的压力
 - css放在页面最上面，JS放在最下面。       因为浏览器的渲染是在加载完全部的css后开始的。 JS会在下载之后就执行，这个时候有可能阻塞页面显示。
 - 减少cookie传输   仔细考量放入cookie的内容，使用独立的域名来下载静态资源设定这些静态资源不需要传入cookie
###CDN
    内容分发网络。    网络第一跳。 缓存静态资源。  动态资源才连接网站服务器
###反向代理
    在网站机房前端，  代理网站接受http请求，有安全，负载均衡和缓存的作用，一些静态资源甚至动态资源都可以缓存在这里

##应用服务器性能优化
###分布式缓存
    **优先考虑使用缓存优化性能。**            保存访问频繁很少改变的数据，或者比较大的计算结果。
    一些使用缓存的注意点：
 - 频繁修改的数据不用缓存
 - 没有热点的访问不用缓存
 - 数据不一致与脏读        失效会查数据库，但是会有时间差，应用要允许时间差
 - 缓存可用性        应用可能会越来越依赖缓存，如果宕机会给数据库带来瞬间压力。一般的的方式是集群，把数据分片存储。
 - 预热        预先加载数据
 - 缓存穿透  可能是一种攻击数据库的手段。可以把不存在的数据也缓存为null等手段，具体问题具体分析。
###Memcached
高性能的互不通信的服务器集群，可伸缩的架构。

![](http://git.oschina.net/wzj777/princeWiki/raw/master/pic/struts/s-8.png)

使用一致性Hash等路由协议来选择服务器，服务期间不进行通讯。
 - 协议。  通信协议使用TCP， 数据序列化方式使用基于文本的自定义协议。非常简单mingling<操作数>这样的结构。其他的还有JSON，XML,二进制等等
 - 客户端    很丰富
 - 高性能网络通信  基于Libevent,长连接表现稳定，支持事件
 - 高效的内存管理    使用固定内存分配。内存分为多个slab,每个slab有固定大小的chunk.含有相同大小的chunk可以构建为slab_class.分配内存是找最接近要存数据的chunk. 可能会有空间浪费，但是内存处理起来很方便。  基于LRU算法释放最久未被访问的数据
 - 互不通信的服务器，使用一致性hash等路由算法
###异步操作
 高并发时响应延迟，数据库压力大。  通过消息队列的异步处理实现削峰。
 因为是异步，有可能失败。要注意失败后的业务处理
**任何能晚点做的事情都晚点做**
###使用集群
    需要负载均衡服务器
###代码优化
####多线程
两个目的使用：IO阻塞与多CPU。  IO会有很长的时间，可以单一线程监控，多路处理的方式。  另外就是多线程可以更好的利用多CPU。
启动线程数 = [任务执行时间/（任务执行时间-IO等待时间）] * CPU内核数
注意线程安全：
 - 将对象设置为无状态对象。 就是无成员变量。或者成员变量也无状态
 - 局部对象
 - 并访问资源加锁
####资源复用
数据库连接池。 对象池，线程池，单例。
####hash,  因为现在的一些hash算法随机性不够，所以可能用到需要先MD5该字符串，在hash计算
####垃圾回收   分代收集，应该尽量减少full gc.
##存储性能优化
###磁盘和SSD
显然SSD要快很多
###B+树vs LSM树
都利用了磁盘是安页读取的特点。
对于现在的数据库等应用使用B+树一般最多三层，这样就需要两次随机I/O才能确定数据索引。
很多nosql数据库使用LSM树。是一个合并树。写删除修改等都会创建新的节点而不是删除或修改节点。  在内存中操作。如果超过内存的阈值会跟磁盘数的下一层数进行合并。  因为查找是首先使用内存的，因此速度比较快。更主要的是优化了写性能。