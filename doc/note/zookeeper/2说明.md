开发者 设计 他们的程序作为一个client连接到ZK. 通过ZK Client API 访问ZK Server
ZK提供如下特性：
    强一致性， 有序性和耐久性。
同步原语
在实际分布式系统中，提供典型的分布式原语。
以前已经有程序实现了分布式锁管理啊， 或者用于协调分布式数据库啊，zk则专注于专门解决这类型的问题。

ZK更加专注于协调任务， 让人们更加专注于写业务代码而不是把大量精力用在分布式概念上。

##ZK不做什么：
不适合做大量的存储， 可以使用数据库。
用来分来应用数据和 控制协调类型的数据。

ZK实现了一个分布式系统的核心操作集。

分布式应用一般都有一个master,或者需要跟踪活着的进程。
ZK提供一定的工具这样的功能。

分布式系统通常有两种通讯选项，一个是共享内存，一个是基于消息传递。

使用ZK可以看作是用了一大块共享内存。
但是ZK自己本身的同步是基于消息传递的。

###例子：Master-Worker 应用

![](http://git.oschina.net/wzj777/princeWiki/raw/master/pic/zookeeper/zk-1.png)

一个典型的样子， 这个要保证高可用，要防止Master 挂，  Worker挂等问题。
Master负责 跟踪worker的存活状态和分配任务。
这个时候我们会遇到的问题： Master Failures, Worker Failures.

#### Master Failures
解决这个问题，需要有一个备， 当主挂掉之后，备取代主的角色。并不是简单的启动起来，然后开始处理请求这么简单。  一个新的Master必须能够恢复整个系统的状态，我们想要拉取这个状态不能从原来的主拉取，而是需要从另外一个地方，这个地方就是ZK。

除了拉取以外，还有别的问题，比如备怀疑主挂了。并且监测的时候因为延迟等问题真的变成主了，这时候就脑裂了。 需要尽量避免脑裂的问题。

####Worker Failure
Master需要知道Worker挂掉了。  决定本来由崩溃这台机器处理的由别人谁来处理。

####网络断了
Worker断掉了到主的链接，有可能导致同一个任务发给两个人。

根据上面所说的，我们能提取出来一个Master-Worker的架构应该包含：
    Master 选举
        保证有一个Master或者，来给worker分配任务。
    碰撞检测
        Master知道一个Worker什么时候挂掉了，或者断开连接了。
    组成员管理
        Master需要找出哪些Worker来执行任务。
    元数据管理
        Master和Worker必须    用可靠的方式存储分配和执行的状态。
ZK提供了核心的机制来实现这样的原语， 使开发人员能够实现他们最适合的需求，并且关注于业务逻辑。

##为什么分布式协调很难。
   只要是分布式系统，就会有很多并发症。
    例如， 如果应用需要读取配置，那么每个当配置改变的时候，我们可能需要做的是关掉然后同步配置文件，再重启，这样就会曾I啊家停机时间。
    除此之外，如果我们还想动态的添加或者删除新的机器，那么就也需要这样子做。
    除了以上这些功能性的，更难处理的是一些错误。比如：宕机和网络断掉的问题，这些问题是随时都有可能发生的。
    
分布式应用的另一个独有的错误是，有可能是部分系统出现问题。
    FLP在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！
    ZK也不能，我们需要做一些妥协来使用ZK，保证了绝大多数的一致性。